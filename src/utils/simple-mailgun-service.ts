import { EventEmitter } from 'events';
import { Logger } from 'winston';
import fetch from 'node-fetch';
import FormData from 'form-data';

export interface MailgunConfig {
  enabled: boolean;
  apiKey: string;
  domain: string;
  from: string;
  to: string[];
}

export enum NotificationLevel {
  INFO = 'info',
  WARNING = 'warning',
  CRITICAL = 'critical',
  SUCCESS = 'success'
}

export interface NotificationMessage {
  level: NotificationLevel;
  title: string;
  message: string;
  details?: any;
  timestamp?: Date;
}

export class SimpleMailgunService extends EventEmitter {
  private config: MailgunConfig;
  private logger: Logger;

  constructor(config: MailgunConfig, logger: Logger) {
    super();
    this.config = config;
    this.logger = logger;

    if (config.enabled && config.apiKey && config.domain) {
      this.logger.info(`üìß Mailgun service initialized for domain: ${config.domain}`);
    }
  }

  public async send(notification: NotificationMessage): Promise<void> {
    if (!this.config.enabled || !this.config.apiKey || !this.config.domain) {
      this.logger.debug('Mailgun not configured, skipping email');
      return;
    }

    notification.timestamp = notification.timestamp || new Date();

    try {
      const subject = `[${notification.level.toUpperCase()}] SPX Straddle Bot - ${notification.title}`;
      const htmlBody = this.generateHTML(notification);
      const textBody = this.generateText(notification);

      // Use FormData like the original cloud function
      const form = new FormData();
      form.append('from', this.config.from);
      form.append('to', this.config.to.join(','));
      form.append('subject', subject);
      form.append('html', htmlBody);
      form.append('text', textBody);

      this.logger.debug(`üìß Sending email to: ${this.config.to.join(',')}`);
      
      // Use the Mailgun REST API directly (like the cloud function approach)
      const response = await fetch(`https://api.mailgun.net/v3/${this.config.domain}/messages`, {
        method: 'POST',
        headers: {
          'Authorization': `Basic ${Buffer.from(`api:${this.config.apiKey}`).toString('base64')}`
        },
        body: form
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Mailgun API failed (${response.status}): ${errorText}`);
      }

      const result = await response.json();
      
      this.logger.info(`‚úÖ Email sent successfully: ${result.id || 'sent'}`);
      this.emit('emailSent', notification);

    } catch (error: any) {
      this.logger.error('‚ùå Failed to send Mailgun email:', error);
      throw new Error(`Mailgun API failed: ${error.message}`);
    }
  }

  private generateHTML(notification: NotificationMessage): string {
    const color = this.getHeaderColor(notification.level);
    const emoji = this.getEmoji(notification.level);

    return `
<!DOCTYPE html>
<html>
<head>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; line-height: 1.6; color: #333; }
        .header { background: ${color}; color: white; padding: 20px; text-align: center; }
        .content { padding: 20px; }
        .details { background: #f5f5f5; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .footer { text-align: center; color: #666; font-size: 12px; padding: 10px; border-top: 1px solid #eee; margin-top: 20px; }
        pre { background: #f8f9fa; padding: 10px; border-radius: 4px; overflow-x: auto; }
    </style>
</head>
<body>
    <div class="header">
        <h1>${emoji} ${notification.title}</h1>
    </div>
    <div class="content">
        <p><strong>Message:</strong></p>
        <p>${notification.message}</p>
        ${notification.details ? `
            <div class="details">
                <h3>Details:</h3>
                <pre>${JSON.stringify(notification.details, null, 2)}</pre>
            </div>
        ` : ''}
        <p><strong>Time:</strong> ${notification.timestamp?.toLocaleString()}</p>
        <p><strong>Level:</strong> ${notification.level.toUpperCase()}</p>
    </div>
    <div class="footer">
        <p>SPX Straddle Trading Bot</p>
        <p>Generated at ${notification.timestamp?.toISOString()}</p>
    </div>
</body>
</html>`;
  }

  private generateText(notification: NotificationMessage): string {
    let text = `SPX STRADDLE BOT NOTIFICATION\n`;
    text += `${'='.repeat(40)}\n\n`;
    text += `TITLE: ${notification.title}\n`;
    text += `LEVEL: ${notification.level.toUpperCase()}\n`;
    text += `TIME: ${notification.timestamp?.toLocaleString()}\n\n`;
    text += `MESSAGE:\n${notification.message}\n\n`;
    
    if (notification.details) {
      text += `DETAILS:\n${JSON.stringify(notification.details, null, 2)}\n\n`;
    }
    
    text += `Generated by SPX Straddle Trading Bot\n`;
    return text;
  }

  private getHeaderColor(level: NotificationLevel): string {
    switch (level) {
      case NotificationLevel.INFO: return '#3498db'; // Blue
      case NotificationLevel.WARNING: return '#f39c12'; // Orange
      case NotificationLevel.CRITICAL: return '#e74c3c'; // Red
      case NotificationLevel.SUCCESS: return '#2ecc71'; // Green
      default: return '#95a5a6'; // Gray
    }
  }

  private getEmoji(level: NotificationLevel): string {
    switch (level) {
      case NotificationLevel.INFO: return '‚ÑπÔ∏è';
      case NotificationLevel.WARNING: return '‚ö†Ô∏è';
      case NotificationLevel.CRITICAL: return 'üö®';
      case NotificationLevel.SUCCESS: return '‚úÖ';
      default: return 'üì¢';
    }
  }

  // Predefined notification templates
  public async sendTradeOpened(position: any): Promise<void> {
    await this.send({
      level: NotificationLevel.INFO,
      title: 'Straddle Position Opened',
      message: `Entered ${position.strike} straddle at $${position.totalEntryPrice.toFixed(2)}`,
      details: {
        strike: position.strike,
        spxPrice: position.spxPrice,
        callPrice: position.callEntryPrice,
        putPrice: position.putEntryPrice,
        totalCost: position.totalEntryPrice * position.quantity * 100,
        target: position.targetPrice,
        stop: position.stopPrice,
        entryTime: position.entryTime
      }
    });
  }

  public async sendTradeClosed(position: any): Promise<void> {
    const pnlPercent = (position.pnl / (position.totalEntryPrice * position.quantity * 100)) * 100;
    const level = position.pnl > 0 ? NotificationLevel.SUCCESS : NotificationLevel.WARNING;

    await this.send({
      level,
      title: 'Straddle Position Closed',
      message: `Closed ${position.strike} straddle - P&L: $${position.pnl.toFixed(2)} (${pnlPercent.toFixed(1)}%)`,
      details: {
        exitReason: position.exitReason,
        strike: position.strike,
        entryPrice: position.totalEntryPrice,
        exitPrice: position.totalExitPrice,
        pnl: position.pnl,
        pnlPercent: pnlPercent.toFixed(1) + '%',
        duration: Math.floor((new Date(position.exitTime).getTime() - new Date(position.entryTime).getTime()) / 60000) + ' minutes'
      }
    });
  }

  public async sendCriticalAlert(title: string, message: string, details?: any): Promise<void> {
    await this.send({
      level: NotificationLevel.CRITICAL,
      title,
      message,
      details
    });
  }

  public async sendDailySummary(summary: any): Promise<void> {
    const level = summary.dailyPnL > 0 ? NotificationLevel.SUCCESS : NotificationLevel.INFO;
    
    await this.send({
      level,
      title: 'Daily Trading Summary',
      message: `Daily P&L: $${summary.dailyPnL.toFixed(2)} | Win Rate: ${summary.winRate.toFixed(1)}%`,
      details: {
        dailyPnL: '$' + summary.dailyPnL.toFixed(2),
        totalTrades: summary.totalTrades,
        winRate: summary.winRate.toFixed(1) + '%',
        uptime: summary.uptime
      }
    });
  }

  public async sendStartupNotification(config: any): Promise<void> {
    await this.send({
      level: NotificationLevel.SUCCESS,
      title: 'Bot Started',
      message: `SPX Straddle Bot started successfully in ${config.paperTrading ? 'paper trading' : 'live trading'} mode`,
      details: {
        entryTime: config.entryTime,
        targetProfit: config.targetProfit + '%',
        stopLoss: config.stopLoss ? config.stopLoss + '%' : 'None',
        maxPosition: '$' + config.maxPosition,
        timestamp: new Date().toISOString()
      }
    });
  }
}